/*
 * File:    $HeadURL: https://svn.sourceforge.net/svnroot/jvoicexml/trunk/src/org/jvoicexml/Application.java$
 * Version: $LastChangedRevision: 68 $
 * Date:    $LastChangedDate $
 * Author:  $LastChangedBy: schnelle $
 *
 * JSAPI - An independent reference implementation of JSR 113.
 *
 * Copyright (C) 2012-2014 JVoiceXML group - http://jvoicexml.sourceforge.net
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

package org.jvoicexml.jsapi2.sapi.recognition;

import java.util.List;
import java.util.Stack;

import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;


/**
 * Content handler to extract the SML interpretation from SML string.
 * <p>
 * SML stands for SAPI Semantic markup language which is the XML document
 * returned by SAPI 6.0 when an
 * utterance is determined to be in-grammar. (SAPI SML is a SAPI-specific return
 * format. SALT interpreters are agnostic to the actual content format of the
 * returned document, provided it is an XML document).
 * SAPI SML contains semantic values, confidence scores and the words used by
 * the speaker. (It is generated by script or XSLT instructions contained within
 * the grammar rules.)
 * </p>
 *
 * @author Dirk Schnelle-Walka
 */
public final class SmlInterpretationExtractor implements ContentHandler {
    /** Intermediately read string between two tags. */
    private StringBuilder str;

    /** Intermediately read string between the SML tags. */
    private StringBuilder strTag;

    /** The current tag prefix. */
    private Stack<String> tagprefixes;

    /** Collected semantic interpretations. */
    private List<SmlInterpretation> interpretations;

    /** The utterance. */
    private String utterance;

    /** The tag for the utterance. */
    private String utteranceTag;

    /** Confidence in the utterance. */
    private float confidence;

    @Override
    public void setDocumentLocator(Locator locator) {
    }

    @Override
    public void startDocument() throws SAXException {
        interpretations = new java.util.ArrayList<>();
        tagprefixes = new java.util.Stack<>();
    }

    @Override
    public void endDocument() throws SAXException {
    }

    @Override
    public void startPrefixMapping(String prefix, String uri)
            throws SAXException {
    }

    @Override
    public void endPrefixMapping(String prefix) throws SAXException {
    }

    @Override
    public void startElement(String uri, String localName,
                             String qName, Attributes atts) throws SAXException {
        if (localName.equalsIgnoreCase("SML")) {
            utterance = atts.getValue("text");
            String conf = atts.getValue("confidence");
            if (conf != null) {
                confidence = Float.parseFloat(conf);
            }
            strTag = new StringBuilder();
        } else {
            StringBuilder tag = new StringBuilder();
            for (int i = 0; i < tagprefixes.size(); i++) {
                String tagprefix = tagprefixes.get(i);
                if (i != 0) {
                    tag.append('.');
                }
                tag.append(tagprefix);
            }
            if (!tag.isEmpty()) {
                tag.append('.');
            }
            tag.append(localName);
            tagprefixes.push(localName);
            String conf = atts.getValue("confidence");
            float fconf = 0.0f;
            if (conf != null) {
                fconf = Float.parseFloat(conf);
            }
            SmlInterpretation interpretation =
                    new SmlInterpretation(tag.toString(), fconf);
            interpretations.add(interpretation);
            str = new StringBuilder();
        }
    }

    @Override
    public void endElement(String uri, String localName,
                           String qName)
            throws SAXException {
        if (localName.equalsIgnoreCase("SML")) {
            utteranceTag = strTag.toString().trim();
            strTag = null;
        } else if (str != null) {
            SmlInterpretation interpretation =
                    findInterpretation(localName);
            if (interpretation != null) {
                interpretation.setValue(str.toString());
            }
            str = null;
        }
        if (!tagprefixes.isEmpty()) {
            tagprefixes.pop();
        }
    }

    /**
     * Finds the interpretation with the given local name.
     *
     * @param localName the local name to look for
     * @return found interpretation
     */
    private SmlInterpretation findInterpretation(String localName) {
        String prefixedName = "." + localName;
        for (int i = interpretations.size() - 1; i >= 0; i--) {
            SmlInterpretation interpretation = interpretations.get(i);
            String tag = interpretation.getTag();
            if (tag.endsWith(prefixedName) || tag.equals(localName)) {
                return interpretation;
            }
        }
        return null;
    }

    @Override
    public void characters(char[] ch, int start, int length)
            throws SAXException {
        if (str != null) {
            str.append(ch, start, length);
        } else if (strTag != null) {
            strTag.append(ch, start, length);
        }
    }

    @Override
    public void ignorableWhitespace(char[] ch, int start,
                                    int length) throws SAXException {
    }

    @Override
    public void processingInstruction(String target, String data)
            throws SAXException {
    }

    @Override
    public void skippedEntity(String name) throws SAXException {
    }

    /**
     * Retrieves the utterance.
     *
     * @return the utterance
     */
    public String getUtterance() {
        return utterance;
    }

    /**
     * Retrieves the tag for the utterance.
     *
     * @return tag for the utterance
     */
    public String getUtteranceTag() {
        return utteranceTag;
    }

    /**
     * Retrieves the confidence.
     *
     * @return the confidence
     */
    public float getConfidence() {
        return confidence;
    }

    /**
     * Retrieves all interpretations.
     *
     * @return all interpretations
     */
    public List<SmlInterpretation> getInterpretations() {
        return interpretations;
    }
}
